# hls-lookup - jump to third party definitions

This project started as an exploration / proof of concept of how a jump to third party definition mechanism could work for Haskell.
I wanted something like what JetBrains Rider does for C#: it downloads assemblies and decompiles them, so I can inspect the code I'm using.

It has two components:
- hls-lookup
    - the cli tool that has to be installed and does the actual work
- hls-lookup-vscode
    - the vscode extension that calls hls-lookup when you ctrl-click on a third-party symbol that is *not* part of base
    - I chose to exclude base symbols, because hls already provides links for the base source

## How it works
1. Uses hie files to determine symbol under cursor and its unit id
1. Uses cabal's plan.json to determine the hackage package and version id of that symbol
1. Downloads the package from hackage and unzips it to ~/.hls-lookup/haskell-sources/
1. Guesses the file location inside of that package
1. Guesses the symbol's location in that file
1. Opens the file in a new tab
1. If any of the previous steps failed it does nothing

The guessing part is troublesome but in practice works well enough. It depends on the package having a fairly standard structure.
In theory one could jump to the third party defitinion of third party references as well, but that requires that the package has hie files as well. As far as I understand those can only be generated by compiling the third party dependency. If there was a way to generate hie files without recompiling or the package delivers hie files through other means, it is perceivable to jump through the whole ecosystem.

## Future plans
- Support git repo dependencies
    - Should be rather simple as no package version needs to be figured out

## Usage
